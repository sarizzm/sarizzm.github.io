<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java-4-面向对象 | codemk</title><meta name="description" content="[TOC] java-面向对象继承性(inheritance) 为什么要有继承？ 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。 此处的多个类称为子类(派生类)， 单独的这个类称为父类(基类或超类)。 可以理解为:“子类 is a 父类” 类继承语法规则:  class Subclass extends SuperClass{"><meta name="keywords" content="super,多态,Object类,toString,包装类"><meta name="author" content="zhouzhm"><meta name="copyright" content="zhouzhm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sarizzm.github.io/2020/12/26/java-ji-chu-4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="java-4-面向对象"><meta property="og:url" content="https://sarizzm.github.io/2020/12/26/java-ji-chu-4/"><meta property="og:site_name" content="codemk"><meta property="og:description" content="[TOC] java-面向对象继承性(inheritance) 为什么要有继承？ 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。 此处的多个类称为子类(派生类)， 单独的这个类称为父类(基类或超类)。 可以理解为:“子类 is a 父类” 类继承语法规则:  class Subclass extends SuperClass{"><meta property="og:image" content="https://i.loli.net/2020/12/06/CoTJ62bqwe7hUng.jpg"><meta property="article:published_time" content="2020-12-26T07:35:00.000Z"><meta property="article:modified_time" content="2020-12-21T15:48:41.278Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?dbfd5dc029096b5047ace83699a50000";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: zhouzhm","link":"链接: ","source":"来源: codemk","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"富强,自由,爱国,文明,和谐","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-12-21 23:48:41'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/images/ava1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">106</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">35</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">java-面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7-inheritance"><span class="toc-number">1.1.</span> <span class="toc-text">继承性(inheritance)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">作用：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99-override-overwrite"><span class="toc-number">1.2.</span> <span class="toc-text">方法的重写(override&#x2F;overwrite)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99-%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">方法的重载与重写 （总结）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94super"><span class="toc-number">1.3.</span> <span class="toc-text">关键字—super</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">调用父类的构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.2.</span> <span class="toc-text">this和super的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">子类对象的实例化过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">super 关键字-小结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#super%E8%B0%83%E7%94%A8%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">super调用属性、方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#super%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%9A"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">super调用构造器：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E8%A7%A3%E9%87%8A"><span class="toc-number">1.4.1.</span> <span class="toc-text">多态解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-Virtual-Method-Invocation"><span class="toc-number">1.4.2.</span> <span class="toc-text">虚拟方法调用(Virtual Method Invocation)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.4.3.</span> <span class="toc-text">instanceof 操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-Casting"><span class="toc-number">1.4.4.</span> <span class="toc-text">对象类型转换 (Casting )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.5.</span> <span class="toc-text">多态小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">Object 类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">Object类中的主要结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8Eequals%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">&#x3D;&#x3D;操作符与equals方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%9A"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">&#x3D; &#x3D;：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#equals"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">equals</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%86%99equals-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">重写equals()方法的原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">&#x3D;&#x3D;和equals的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#toString-%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">toString() 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">包装类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-gt-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.6.2.</span> <span class="toc-text">基本类型&#x3D;&gt;包装类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-gt-String-%E7%B1%BB"><span class="toc-number">1.6.3.</span> <span class="toc-text">基本类型&#x3D;&gt;String 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.6.4.</span> <span class="toc-text">用法举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%86%E7%AE%B1%EF%BC%9A"><span class="toc-number">1.6.5.</span> <span class="toc-text">拆箱：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.6.6.</span> <span class="toc-text">实例：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">参考：</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/12/06/CoTJ62bqwe7hUng.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">codemk</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">java-4-面向对象</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-26T07:35:00.000Z" title="发表于 2020-12-26 15:35:00">2020-12-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-21T15:48:41.278Z" title="更新于 2020-12-21 23:48:41">2020-12-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><a id="more"></a>
<p>[TOC]</p>
<h2 id="java-面向对象"><a href="#java-面向对象" class="headerlink" title="java-面向对象"></a>java-面向对象</h2><h3 id="继承性-inheritance"><a href="#继承性-inheritance" class="headerlink" title="继承性(inheritance)"></a>继承性(inheritance)</h3><ul>
<li>为什么要有继承？</li>
<li>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</li>
<li>此处的多个类称为子类(派生类)， 单独的这个类称为父类(基类或超类)。 可以理解为:“子类 is a 父类”</li>
<li>类继承语法规则:  <code>class Subclass extends SuperClass{ }</code></li>
</ul>
<h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ul>
<li><p>继承的出现减少了代码冗余，提高了代码的复用性。</p>
</li>
<li><p>继承的出现，更有利于功能的扩展。</p>
</li>
<li><p>继承的出现让类与类之间产生了关系，提供了多态的前提。</p>
</li>
<li><p>==注意：不要仅为了获取其他类中某个功能而去继承== </p>
</li>
<li><p>子类继承了父类，就继承了父类的方法和属性。</p>
</li>
<li><p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。</p>
</li>
<li><p>在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展” 。</p>
</li>
</ul>
<p><strong>关于继承的规则：子类不能直接访问父类中私有的(private)的成员变量和方法。</strong> </p>
<p><strong>Java只支持单继承和多层继承， 不允许多重继承**</strong></p>
<ul>
<li>一个子类只能有一个父类<ul>
<li>一个父类可以派生出多个子类<ul>
<li>class SubDemo extends Demo{ } //ok</li>
<li>class SubDemo extends Demo1,Demo2…//error </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="方法的重写-override-overwrite"><a href="#方法的重写-override-overwrite" class="headerlink" title="方法的重写(override/overwrite)"></a>方法的重写(override/overwrite)</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h4><p>在子类中可以根据需要对从父类中继承来的方法进行改造， 也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。<br><strong>要求：</strong></p>
<ol>
<li><p>子类重写的方法必须和父类被重写的方法具有相同的方法名称、 参数列表</p>
</li>
<li><p>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</p>
<blockquote>
<ol>
<li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li>
<li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</li>
<li>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</li>
</ol>
</blockquote>
</li>
<li><p>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限</p>
<ul>
<li>子类不能重写父类中声明为private权限的方法</li>
</ul>
</li>
<li><p>子类方法抛出的异常不能大于父类被重写方法的异常</p>
<p><strong>注意：</strong></p>
<p>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写） 。因为static方法是属于类的，子类无法覆盖父类的方法。 </p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{ </span><br><span class="line">    <span class="keyword">public</span> String name; <span class="keyword">public</span> <span class="keyword">int</span> age; <span class="comment">//重写方法举例(1)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Name: "</span>+ name + <span class="string">"\n"</span> +<span class="string">"age: "</span>+ age;</span><br><span class="line">		}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{</span><br><span class="line">	<span class="keyword">public</span> String school;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>{ <span class="comment">//重写方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Name: "</span>+ name + <span class="string">"\nage: "</span>+ age+ <span class="string">"\nschool: "</span>+ school;</span><br><span class="line">		}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">	Student s1=<span class="keyword">new</span> Student();</span><br><span class="line">	s1.name=<span class="string">"Bob"</span>;</span><br><span class="line">	s1.age=<span class="number">20</span>;</span><br><span class="line">	s1.school=<span class="string">"school2"</span>;</span><br><span class="line">	System.out.println(s1.getInfo()); <span class="comment">//Name:Bob age:20 school:school2</span></span><br><span class="line">		}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person p1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//调用Person类的getInfo()方法</span></span><br><span class="line">p1.getInfo();</span><br><span class="line">Student s1=<span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//调用Student类的getInfo()方法</span></span><br><span class="line">s1.getInfo();</span><br><span class="line"><span class="comment">//这是一种“多态性”：同名的方法，用不同的对象来区分调用的是哪一个方法。</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="方法的重载与重写-（总结）"><a href="#方法的重载与重写-（总结）" class="headerlink" title="方法的重载与重写 （总结）"></a>方法的重载与重写 （总结）</h4><blockquote>
<p>​    重载，是指允许存在多个同名方法，而这些方法的参数不同。 编译器根据方法不同的参数表， 对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。 它们的调用地址在编译期就绑定了。 Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</p>
<p>​    所以： 对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定” ；</p>
<p>​    而对于多态，只有等到方法调用的那一刻， 解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定” 。</p>
<p>引用一句Bruce Eckel的话： “不要犯傻，如果它不是晚绑定， 它就不是多态。” </p>
</blockquote>
<h3 id="关键字—super"><a href="#关键字—super" class="headerlink" title="关键字—super"></a>关键字—super</h3><p><strong>在Java类中使用super来调用父类中的指定操作：</strong></p>
<blockquote>
<ol>
<li>super可用于访问父类中定义的属性</li>
<li>super可用于调用父类中定义的成员方法</li>
<li>super可用于在子类构造器中调用父类的构造器</li>
</ol>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<ol>
<li>尤其当子父类出现同名成员时， 可以用super表明调用的是父类中的成员</li>
<li>super的追溯不仅限于直接父类</li>
<li>super和this的用法相像， this代表本类对象的引用， super代表父类的内存空间的标识 </li>
</ol>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">protected</span> <span class="title">Person</span> </span>{</span><br><span class="line">    String name = <span class="string">"张三"</span>; <span class="comment">//关键字super举例</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Name: "</span> + name + <span class="string">"\nage: "</span> + age;</span><br><span class="line">		}</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{</span><br><span class="line">	<span class="keyword">protected</span> String name = <span class="string">"李四"</span>;</span><br><span class="line">	<span class="keyword">private</span> String school = <span class="string">"New Oriental"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSchool</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> school;</span><br><span class="line">			}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.getInfo() + <span class="string">"\nschool: "</span> + school;</span><br><span class="line">			}}</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">	Student st = <span class="keyword">new</span> Student();</span><br><span class="line">	System.out.println(st.getInfo());</span><br><span class="line">		}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="调用父类的构造器"><a href="#调用父类的构造器" class="headerlink" title="调用父类的构造器"></a>调用父类的构造器</h4><p><strong>子类中所有的构造器默认都会访问父类中空参数的构造器</strong></p>
<ul>
<li>当父类中没有空参数的构造器时， 子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。 同时， 只能”二选一”， 且必须放在构造器的首行</li>
<li>如果子类构造器中既未显式调用父类或本类的构造器， 且父类中又没有无参的构造器， ==则编译出错== </li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> String school;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, String s)</span> </span>{</span><br><span class="line">	<span class="keyword">super</span>(name, age);</span><br><span class="line">	school = s;</span><br><span class="line">	}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String s)</span> </span>{</span><br><span class="line">	<span class="keyword">super</span>(name);</span><br><span class="line">	school = s;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 编译出错: no super(),系统将调用父类无参数的构造器。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String s)</span> </span>{</span><br><span class="line">	school = s;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h4><div class="table-container">
<table>
<thead>
<tr>
<th>No.</th>
<th>区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>访问属性</td>
<td>访问本类中的属性，如果本类没 有此属性则从父类中继续查找</td>
<td>直接访问父类中的属性</td>
</tr>
<tr>
<td>2</td>
<td>调用方法</td>
<td>访问本类中的方法，如果本类没 有此方法则从父类中继续查找</td>
<td>直接访问父类中的方法</td>
</tr>
<tr>
<td>3</td>
<td>调用构造器</td>
<td>调用本类构造器，必须放在构造 器的首行</td>
<td>调用父类构造器，必须 放在子类构造器的首行</td>
</tr>
</tbody>
</table>
</div>
<h4 id="子类对象的实例化过程"><a href="#子类对象的实例化过程" class="headerlink" title="子类对象的实例化过程"></a>子类对象的实例化过程</h4><p><img src="https://i.loli.net/2020/12/10/XGv1SrHiRxKWC7g.png" alt="43121.png"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Creature</span><span class="params">()</span> </span>{</span><br><span class="line">	System.out.println(<span class="string">"Creature无参数的构造器"</span>);</span><br><span class="line">}}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">Creature</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>{</span><br><span class="line">	System.out.println(<span class="string">"Animal带一个参数的构造器，该动物的name为"</span> + name);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">	<span class="keyword">this</span>(name);</span><br><span class="line">	System.out.println(<span class="string">"Animal带两个参数的构造器，其age为"</span> + age);</span><br><span class="line">}}</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Wolf</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">super</span>(<span class="string">"灰太狼"</span>, <span class="number">3</span>);</span><br><span class="line">	System.out.println(<span class="string">"Wolf无参数的构造器"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">	<span class="keyword">new</span> Wolf();</span><br><span class="line">}}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="super-关键字-小结"><a href="#super-关键字-小结" class="headerlink" title="super 关键字-小结"></a>super 关键字-小结</h4><p><strong>可以理解为：父类的,可以用来调用的结构：属性、方法、构造器</strong></p>
<h5 id="super调用属性、方法："><a href="#super调用属性、方法：" class="headerlink" title="super调用属性、方法："></a>super调用属性、方法：</h5><blockquote>
<ol>
<li>我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</li>
<li>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。</li>
<li>特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</li>
</ol>
</blockquote>
<h5 id="super调用构造器："><a href="#super调用构造器：" class="headerlink" title="super调用构造器："></a>super调用构造器：</h5><blockquote>
<ol>
<li>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</li>
<li>“super(形参列表)”的使用，必须声明在子类构造器的首行！</li>
<li>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二一，不能同时出现</li>
<li>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器:super()</li>
<li>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</li>
</ol>
</blockquote>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><h4 id="多态解释"><a href="#多态解释" class="headerlink" title="多态解释"></a>多态解释</h4><p><strong>多态性，是面向对象中最重要的概念， 在Java中的体现：</strong><br>==对象的多态性：父类的引用指向子类的对象==</p>
<blockquote>
<p>可以直接应用在抽象类和接口上</p>
</blockquote>
<p><strong>Java引用变量有两个类型： 编译时类型和运行时类型。 编译时类型由声明该变量时使用的类型决定， 运行时类型由实际赋给该变量的对象决定。 简称： 编译时， 看左边；运行时， 看右边。</strong></p>
<blockquote>
<ol>
<li>若编译时类型和运行时类型不一致， 就出现了对象的多态性(Polymorphism)</li>
<li>多态情况下， “看左边” ： 看的是父类的引用（父类中不具备子类特有的方法）<pre><code>                                      “看右边” ： 看的是子类的对象（实际运行的是子类重写父类的方法） 
</code></pre></li>
</ol>
</blockquote>
<p><strong>对象的多态 —在Java中,子类的对象可以替代父类的对象使用</strong></p>
<blockquote>
<p>一个变量只能有一种确定的数据类型</p>
<p>一个引用类型变量可能指向(引用)多种不同类型的对象</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">Object o = <span class="keyword">new</span> Person();<span class="comment">//Object类型的变量o， 指向Person类型的对象</span></span><br><span class="line">o = <span class="keyword">new</span> Student(); <span class="comment">//Object类型的变量o， 指向Student类型的对象</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>子类可看做是特殊的父类， 所以父类类型的引用可以指向子类的对象：向上转型(upcasting)</strong> </p>
<p><strong>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student m = <span class="keyword">new</span> Student();</span><br><span class="line">m.school = “pku”; <span class="comment">//合法,Student类有school成员变量</span></span><br><span class="line">Person e = <span class="keyword">new</span> Student();</span><br><span class="line">e.school = “pku”; <span class="comment">//非法,Person类没有school成员变量</span></span><br></pre></td></tr></tbody></table></figure>
<p>==属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。==</p>
<p><strong>方法声明的形参类型为父类类型，可以使用子类的对象作为实参调用该方法</strong> </p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person e)</span> </span>{</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">	e.getInfo();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirng args[])</span> </span>{</span><br><span class="line">	Test t = <span class="keyword">new</span> Test();</span><br><span class="line">	Student m = <span class="keyword">new</span> Student();</span><br><span class="line">	t.method(m); <span class="comment">// 子类的对象m传送给父类类型的参数e</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="虚拟方法调用-Virtual-Method-Invocation"><a href="#虚拟方法调用-Virtual-Method-Invocation" class="headerlink" title="虚拟方法调用(Virtual Method Invocation)"></a>虚拟方法调用(Virtual Method Invocation)</h4><p> <strong>正常的方法调用</strong></p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person e = <span class="keyword">new</span> <span class="constructor">Person()</span>;</span><br><span class="line">e.get<span class="constructor">Info()</span>;</span><br><span class="line">Student e = <span class="keyword">new</span> <span class="constructor">Student()</span>;</span><br><span class="line">e.get<span class="constructor">Info()</span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>虚拟方法调用(多态情况下)</strong><br>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person e = <span class="keyword">new</span> Student();</span><br><span class="line">e.getInfo(); <span class="comment">//调用Student类的getInfo()方法</span></span><br></pre></td></tr></tbody></table></figure>
<p> <strong>编译时类型和运行时类型</strong><br>==编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。 ——动态绑定== </p>
<h4 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h4><p><strong><code>x instanceof A</code>：检验x是否为类A的对象，返回值为boolean型。</strong></p>
<blockquote>
<ul>
<li>要求x所属的类与类A必须是子类和父类的关系，否则编译错误。</li>
<li>如果x属于类A的子类B， x instanceof A值也为true。 </li>
</ul>
</blockquote>
<h4 id="对象类型转换-Casting"><a href="#对象类型转换-Casting" class="headerlink" title="对象类型转换 (Casting )"></a>对象类型转换 (Casting )</h4><p><strong>基本数据类型的Casting：</strong></p>
<blockquote>
<p>自动类型转换：小的数据类型可以自动转换成大的数据类型<br>    如<code>long g=20; double d=12.0f</code><br>强制类型转换： 可以把大的数据类型强制转换(casting)成小的数据类型<br>    如<code>float f=(float)12.0; int a=(int)1200L</code></p>
</blockquote>
<p><strong>对Java对象的强制类型转换称为造型</strong></p>
<blockquote>
<ol>
<li>从子类到父类的类型转换可以自动进行</li>
<li>从父类到子类的类型转换必须通过造型(强制类型转换)实现</li>
<li>无继承关系的引用类型间的转换是非法的</li>
<li>在造型前可以使用instanceof操作符测试一个对象的类型 </li>
</ol>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person e)</span> </span>{ <span class="comment">// 设Person类中没有getschool() 方法</span></span><br><span class="line">	<span class="comment">// System.out.pritnln(e.getschool()); //非法,编译时错误</span></span><br><span class="line">	<span class="keyword">if</span> (e <span class="keyword">instanceof</span> Student) {</span><br><span class="line">		Student me = (Student) e; <span class="comment">// 将e强制转换为Student类型</span></span><br><span class="line">		System.out.pritnln(me.getschool());</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">		Test t = <span class="keyword">new</span> Test();</span><br><span class="line">		Student m = <span class="keyword">new</span> Student();</span><br><span class="line">		t.method(m);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://i.loli.net/2020/12/10/aXGCpfARi8h3FlT.png" alt="1151312.png"></p>
<p><strong>子类继承父类</strong></p>
<blockquote>
<ol>
<li>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量 </li>
</ol>
</blockquote>
<h4 id="多态小结"><a href="#多态小结" class="headerlink" title="多态小结"></a>多态小结</h4><p><strong>多态作用：</strong></p>
<blockquote>
<p>提高了代码的通用性，常称作接口重用</p>
</blockquote>
<p> <strong>前提：</strong></p>
<blockquote>
<p>需要存在继承或者实现关系<br>有方法的重写</p>
</blockquote>
<p><strong>成员方法：</strong></p>
<blockquote>
<p>编译时：要查看引用变量所声明的类中是否有所调用的方法。<br>运行时： 调用实际new的对象所属的类中的重写方法。</p>
</blockquote>
<p> <strong>成员变量：</strong></p>
<blockquote>
<p>不具备多态性，只看引用变量所声明的类。 </p>
</blockquote>
<h3 id="Object-类的使用"><a href="#Object-类的使用" class="headerlink" title="Object 类的使用"></a>Object 类的使用</h3><h4 id="Object类中的主要结构"><a href="#Object类中的主要结构" class="headerlink" title="Object类中的主要结构"></a>Object类中的主要结构</h4><div class="table-container">
<table>
<thead>
<tr>
<th>NO.</th>
<th>方法名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>public Object()</td>
<td>构造</td>
<td>构造器</td>
</tr>
<tr>
<td>2</td>
<td>public boolean equals(Object obj)</td>
<td>普通</td>
<td>对象比较</td>
</tr>
<tr>
<td>3</td>
<td>public int hashCode()</td>
<td>普通</td>
<td>取得Hash码</td>
</tr>
<tr>
<td>4</td>
<td>public String toString()</td>
<td>普通</td>
<td>对象打印时调用</td>
</tr>
</tbody>
</table>
</div>
<h4 id="操作符与equals方法"><a href="#操作符与equals方法" class="headerlink" title="==操作符与equals方法"></a><code>==</code>操作符与<code>equals</code>方法</h4><h5 id="："><a href="#：" class="headerlink" title="= =："></a><code>= =</code>：</h5><p><strong>基本类型比较值:只要两个变量的值相等， 即为true。</strong><br><code>int a=5; if(a==6){…}</code><br><strong>引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时， == 才返回true。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1=<span class="keyword">new</span> Person();</span><br><span class="line">Person p2=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">if</span> (p1== p2){…}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>用<code>“==”</code>进行比较时， 符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)， 否则编译出错</strong> </p>
<h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a><code>equals</code></h5><ul>
<li>equals()：所有类都继承了Object， 也就获得了equals()方法。 还可以重写。</li>
</ul>
<blockquote>
<p>只能比较引用类型， 其作用与“==”相同,比较是否指向同一个对象。<br>格式:<code>obj1.equals(obj2)</code></p>
</blockquote>
<ul>
<li><p>特例：当用equals()方法进行比较时， 对类File、 String、 Date及包装类（Wrapper Class） 来说， 是比较类型及内容而不考虑引用的是否是同一个对象；</p>
<ul>
<li>原因：在这些类中重写了Object类的equals()方法。</li>
</ul>
</li>
<li><p>当自定义使用equals()时， 可以重写。 用于比较两个对象的“内容” 是否都相等 </p>
</li>
</ul>
<h5 id="重写equals-方法的原则"><a href="#重写equals-方法的原则" class="headerlink" title="重写equals()方法的原则"></a>重写equals()方法的原则</h5><p><strong>对称性： 如果x.equals(y)返回是“ true” ， 那么y.equals(x)也应该返回是“true” 。</strong></p>
<blockquote>
<ol>
<li>自反性： x.equals(x)必须返回是“true” 。</li>
<li>传递性： 如果x.equals(y)返回是“true” ， 而且y.equals(z)返回是“true” ，那么z.equals(x)也应该返回是“true” 。</li>
<li>一致性： 如果x.equals(y)返回是“true” ， 只要x和y内容一直不变， 不管你重复x.equals(y)多少次， 返回都是“true” 。</li>
<li>任何情况下， x.equals(null)， 永远返回是“false” ；x.equals(和x不同类型的对象)永远返回是“false” 。 </li>
</ol>
</blockquote>
<h5 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h5><blockquote>
<ol>
<li>== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</li>
<li>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。</li>
<li>具体要看自定义类里有没有重写Object的equals方法来判断。</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性是否都相等。 </li>
</ol>
</blockquote>
<h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> it = <span class="number">65</span>;</span><br><span class="line"><span class="keyword">float</span> fl = <span class="number">65.0f</span>;</span><br><span class="line">System.out.println(“<span class="number">65</span>和<span class="number">65.0f</span>是否相等？ ” + (it == fl)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch1 = <span class="string">'A'</span>; <span class="keyword">char</span> ch2 = <span class="number">12</span>;</span><br><span class="line">System.out.println(<span class="string">"65和'A'是否相等？ "</span> + (it == ch1));<span class="comment">//true</span></span><br><span class="line">System.out.println(“<span class="number">12</span>和ch2是否相等？ <span class="string">" + (12 == ch2));//true</span></span><br><span class="line"><span class="string">                   </span></span><br><span class="line"><span class="string">String str1 = new String("</span>hello<span class="string">");</span></span><br><span class="line"><span class="string">String str2 = new String("</span>hello<span class="string">");</span></span><br><span class="line"><span class="string">System.out.println("</span>str1和str2是否相等？ <span class="string">"+ (str1 == str2));//false</span></span><br><span class="line"><span class="string">                   </span></span><br><span class="line"><span class="string">System.out.println("</span>str1是否equals str2？ <span class="string">"+(str1.equals(str2)));//true</span></span><br><span class="line"><span class="string">                   </span></span><br><span class="line"><span class="string">System.out.println(“hello” == new java.util.Date()); //编译不通过</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a>toString() 方法</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul>
<li><p>toString()方法在Object类中定义， 其返回值是String类型， 返回类名和它的引用地址。</p>
</li>
<li><p>在进行String与其它类型数据的连接操作时， 自动调用toString()方法</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date now=<span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(“now=”+now);<span class="comment">// 相当于</span></span><br><span class="line">System.out.println(“now=”+now.toString());</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可以根据需要在用户自定义类型中重写toString()方法<br>   如String 类重写了toString()方法， 返回字符串的值。</li>
</ul>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1=“hello”;</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(s1);//相当于<span class="keyword">System</span>.<span class="keyword">out</span>.println(s1.toString());</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>基本类型数据转换为String类型时， 调用了对应包装类的toString()方法<br><code>int a=10; System.out.println(“a=”+a);</code></li>
</ul>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[] { <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> };</span><br><span class="line">	System.out.println(arr);<span class="comment">//abc</span></span><br><span class="line">	<span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[] { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };</span><br><span class="line">    System.out.println(arr1);<span class="comment">//[I@1540e19d</span></span><br><span class="line">    <span class="keyword">double</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">double</span>[] { <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span> };</span><br><span class="line">    System.out.println(arr2);<span class="comment">//[D@677327b6</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="包装类的使用"><a href="#包装类的使用" class="headerlink" title="包装类的使用"></a>包装类的使用</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ol>
<li>针对八种基本数据类型定义相应的引用类型—包装类（封装类）</li>
<li>有了类的特点，就可以调用类中的方法， Java才是真正的面向对象 </li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte（父类:Number）</td>
</tr>
<tr>
<td>short</td>
<td>Short（父类:Number）</td>
</tr>
<tr>
<td>int</td>
<td>Integer（父类:Number）</td>
</tr>
<tr>
<td>long</td>
<td>Long（父类:Number）</td>
</tr>
<tr>
<td>float</td>
<td>Float（父类:Number）</td>
</tr>
<tr>
<td>double</td>
<td>Double（父类:Number）</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody>
</table>
</div>
<p><strong>基本数据类型包装成包装类的实例 —-装箱</strong></p>
<h4 id="基本类型-gt-包装类"><a href="#基本类型-gt-包装类" class="headerlink" title="基本类型=>包装类"></a>基本类型=&gt;包装类</h4><ul>
<li>通过包装类的构造器实现：<br><code>·int i = 500; Integer t = new Integer(i);·</code></li>
<li>还可以通过字符串参数构造包装类对象：<br><code>Float f = new Float(“4.56”);</code><br><code>Long l = new Long(“asdf”); //NumberFormatException</code></li>
<li>获得包装类对象中包装的基本类型变量 —-拆箱<ul>
<li>调用包装类的.xxxValue()方法：<br><code>boolean b = bObj.booleanValue();</code></li>
</ul>
</li>
<li>JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。 </li>
</ul>
<h4 id="基本类型-gt-String-类"><a href="#基本类型-gt-String-类" class="headerlink" title="基本类型=>String 类"></a>基本类型=&gt;String 类</h4><ul>
<li><p>字符串转换成基本数据类型</p>
<ul>
<li>通过包装类的构造器实现：<br><code>int i = new Integer(“12”);</code></li>
<li>通过包装类的parseXxx(String s)静态方法：<br><code>Float f = Float.parseFloat(“12.1”);</code></li>
</ul>
</li>
<li><p>基本数据类型转换成字符串</p>
<ul>
<li>调用字符串重载的valueOf()方法：<br><code>String fstr = String.valueOf(2.34f);</code></li>
<li>更直接的方式：<br><code>String intStr = 5 + “”</code></li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/12/10/VRtyGF1zXUN8Oba.png" alt="62651.png"></p>
<h4 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">Integer t = <span class="keyword">new</span> Integer(i);</span><br><span class="line"><span class="comment">//装箱：包装类使得一个基本数据类型的数据变成了类。</span></span><br><span class="line"><span class="comment">//有了类的特点，可以调用类中的方法。</span></span><br><span class="line">String s = t.toString(); <span class="comment">// s = “500“,t是类，有toString方法</span></span><br><span class="line">String s1 = Integer.toString(<span class="number">314</span>); <span class="comment">// s1= “314“ 将数字转换成字符串。</span></span><br><span class="line">String s2=“<span class="number">4.56</span>”;</span><br><span class="line"><span class="keyword">double</span> ds=Double.parseDouble(s2); <span class="comment">//将字符串转换成数字</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="拆箱："><a href="#拆箱：" class="headerlink" title="拆箱："></a>拆箱：</h4><p><strong>将数字包装类中内容变为基本数据类型。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = t.intValue(); <span class="comment">// j = 500， intValue取出包装类中的数据</span></span><br><span class="line"><span class="comment">//包装类在实际开发中用的最多的在于字符串变为基本数据类型。</span></span><br><span class="line">String str1 = <span class="string">"30"</span> ;</span><br><span class="line">String str2 = <span class="string">"30.3"</span> ;</span><br><span class="line"><span class="keyword">int</span> x = Integer.parseInt(str1) ; <span class="comment">// 将字符串变为int型</span></span><br><span class="line"><span class="keyword">float</span> f = Float.parseFloat(str2) ; <span class="comment">// 将字符串变为int型 </span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o1);<span class="comment">// 1.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Object o2;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>)</span><br><span class="line">o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o2);<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>{</span><br><span class="line">    Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line">    Integer m = <span class="number">1</span>;</span><br><span class="line">    Integer n = <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n);<span class="comment">//true</span></span><br><span class="line">    Integer x = <span class="number">128</span>;</span><br><span class="line">    Integer y = <span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y);<span class="comment">//false</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kb411W75N?p=2">尚硅谷_Java零基础教程-java入门必备-适合初学者的全套完整版教程(宋红康主讲)</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhouzhm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://sarizzm.github.io/2020/12/26/java-ji-chu-4/">https://sarizzm.github.io/2020/12/26/java-ji-chu-4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sarizzm.github.io" target="_blank">codemk</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/12/06/CoTJ62bqwe7hUng.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src="/images/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/images/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/27/leecode-27-yi-chu-yuan-su/"><img class="prev-cover" src="https://i.loli.net/2020/12/06/dn4r9uLVwlyjYK8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">leecode-27-移除元素</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/23/leecode-20-you-xiao-gua-hao/"><img class="next-cover" src="https://i.loli.net/2020/12/06/B1yCdmPaEA7NlJt.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leecode-20-有效的括号</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/11/20/java-ji-chu-1/" title="java-1-语言特点-注释-标识符-进制"><img class="cover" src="https://i.loli.net/2020/12/10/oXAi1sJhU7L9QzR.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-20</div><div class="title">java-1-语言特点-注释-标识符-进制</div></div></a></div><div><a href="/2020/11/22/java-ji-chu-2/" title="java-2-运算符-流程控制-数组"><img class="cover" src="https://i.loli.net/2020/12/10/jsMYt2cug8HRTGE.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-22</div><div class="title">java-2-运算符-流程控制-数组</div></div></a></div><div><a href="/2020/11/24/java-ji-chu-3/" title="java-3-面向对象-类-属性-构造器-this-UML图"><img class="cover" src="https://i.loli.net/2020/12/10/82PoJODjxXLI4ry.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-24</div><div class="title">java-3-面向对象-类-属性-构造器-this-UML图</div></div></a></div><div><a href="/2020/12/30/java-xian-cheng-1/" title="java-多线程"><img class="cover" src="https://i.loli.net/2020/12/06/4eXGBKpdCcE6U5A.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-30</div><div class="title">java-多线程</div></div></a></div><div><a href="/2020/12/30/java-ji-chu-5/" title="java-5-面向对象"><img class="cover" src="https://i.loli.net/2020/12/06/vZdJtUMwBQkEHjF.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-30</div><div class="title">java-5-面向对象</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/12/06/CoTJ62bqwe7hUng.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By zhouzhm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">不急不怠，跬步千里</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'ouQRqhHS28VSig7Qdha07YFS-gzGzoHsz',
      appKey: 'sOIyts0asrItui9JkJn2qCoH',
      placeholder: '有问题，请留言......',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/ClickShowText.js" async="async"></script></div></body></html>